<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" >
<head>
    <link rel="stylesheet" type="text/css" href="./supplementary/combined.css" />
    <meta http-equiv="content-language" content="en" />
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <meta name="description" content="Augmenting Predicate Analysis with Auxiliary Invariants" />
    <meta name="keywords" content="Software Model Checking Verification CEGAR Craig Interpolation Path Slicing Refinement Selection Sliced Path Prefixes Prefix automatic automated Auxiliary Invariants Predicate" />
    <title>Augmenting Predicate Analysis with Auxiliary Invariants</title>
</head>

<body>
<div class="paper" id="content">

    <div class="heading">
        <h1>
            Augmenting Predicate Analysis</br>
            with Auxiliary Invariants
        </h1>
        Master's Thesis in Computer Science at the Chair for Software Systems at the University of Passau
    </div>

    <div style="text-align:center; font-size:150%">
        &mdash; Supplementary Web Page &mdash;
    </div>

    <div class="crossref">
        <a href="./supplementary/thesis_stieglmaier.pdf">
            <image src="./supplementary/pdf.png"/>
            Thesis
        </a></br>
        <a href="./supplementary/thesis_presentation_stieglmaier.pdf">
            <image src="./supplementary/pdf.png"/>
            Presentation
        </a>
    </div>

    <p class="author" style="text-align:center;">
        <a href="https://stieglmaier.me">Thomas Stieglmaier</a>
    </p>

    <h2>Abstract</h2>
    <div class="abstract">
    <p>
Predicate analysis is a common approach to software model checking. Abstractions of programs are computed out of predicates found with craig interpolation. The found interpolants are, however,
in some cases not ideal, and lead to long-running verification runs. To reduce the reliance on interpolation this thesis evaluates the effects of using separately computed, auxiliary, invariants instead.</p>
<p>
Our work is based on the CPA concept, CPAchecker and the PredicateCPA. It is split into two major parts, on the one hand we introduce a new algorithm for concurrent execution of several analysis in CPAchecker, as well as communication between such analysis,
and on the other hand we show how the PredicateCPA can be augmented with additional formulas in several ways, we chose to evaluate: appending invariants to the precision of the analysis and 
conjoining invariants either to the path formula or to the abstraction formula. The invariants we want to use are generated by some new approaches directly in CPAchecker. They can
be separated in two classes, on the one hand the on-the-fly and lightweight invariant generation heuristics which try to find invariants for a certain given program location only, and
on the other hand complete analyses, which results are then used for generating invariants for the whole program. </p>
<p>
While the lightweight on-the-fly approaches did not yield the expected results, analyses using concurrently computed invariants perform strictly better than comparable analyses without invariants.</p>
    </div>

    <h2>Complete Results</h2>

    <p>The complete results from our experiments, can be found in the tables listed below. </p>
    <div class="howto">
        <ul>
            <li>Results for (lightweight) heuristics
            <ul>
                <li><a href="./supplementary/tables/heuristics_overall_all.table.html">Best heuristics configurations compared with baseline</a></li>
                <li>Path Invariants:
                    <ul>
                        <li><a href="./supplementary/tables/pathinvariants_all.table.html">300s CPU time</a></li>
                        <li><a href="tables/pathinvariants_long_all.table.html">400s CPU time</a></li>
                    </ul></li>
                <li><a href="./supplementary/tables/weakening_all.table.html">Inductive Weakening of Path Formulas</a></li>
                <li><a href="./supplementary/tables/cnfKind_all.table.html">Checking Conjuncts of Path Formulas on Invariance</a></li>
                <li>Checking Interpolants on Invariance:
                    <ul>
                        <li><a href="./supplementary/tables/interpolKind_all.table.html">abstraction only at loops</a></li>
                        <li><a href="./supplementary/tables/alwaysAtJoin_all.table.html">abstraction at loops and join points</a></li>
                    </ul>
            </ul></li>

            <li>Results for sequential analyses
            <ul>
                <li><a href="./supplementary/tables/restart_all.table.html">Sequential Combinations of Analyses</a></li>
            </ul></li>

            <li>Results for parallel analyses
            <ul>
                <li><a href="./supplementary/tables/parallel_all.table.html">Parallel Combinations of Analyses</a></li>
            </ul></li>
            <li><a href="./supplementary/tables/z3_all.table.html">Results for lightweight heuristics with Z3 as SMT solver</a></li>
        </ul>
    </div>

    <h2>Wrong Invariant</h2>
    <p>In the following paragraph we see a path formula and an invariant for the program <code>heap-manipulation/sll_to_dll_rev_false-unreach-call.i </code> where the conjunction of the invariant and the path formula leads to a wrong proof. This is caused by different handling of pointer variables in the Predicate CPA and the Invariants CPA.
    </p>
    <div class="howto">
        The resulting formula of conjoining <a href="wrongInvariant/pathformula.smt2.txt">this path formula</a> with <a href="wrongInvariant/invariant.smt2.txt">this invariant</a>
        is unsatisatisfiable, leading to a wrong result with the predicate analysis. The <a href="wrongInvariant/interpolant.smt2.txt" >interpolant</a> between these formulas is showing the problem:
        <code>(assert (not (= |main::list@3| (_ bv0 32))))</code> tells us that the variable <code>|main::list@3|</code> has the value <code>0</code>.
        However, this variable is a pointer and the Predicate CPA handles pointers with uninterpreted functions and does not expect that a pointer is <code>0</code>.
        The different values for this variable lead to the unsatisfiability.
        <br><br>
        <p>The following commandline can be used to observe this behavior:</p>
        <code>scripts/cpa.sh<br>
         <span class="prop">-noout</span><br>
         <span class="prop">-heap 6000M</span><br>
         <span class="prop">-setprop solver.solver=MATHSAT5</span><br>
         <span class="prop">-setprop cpa.predicate.refinement.performInitialStaticRefinement=false</span><br>
         <span class="prop">-setprop cpa.predicate.ignoreIrrelevantFields=false</span><br>
         <span class="prop">-setprop cpa.predicate.ignoreIrrelevantVariables=false</span><br>
         <span class="prop">-pred-Invgen-parallel-bitprecise</span><br>
         <span class="prop">-setprop cpa.predicate.invariants.appendToPathFormula=true</span><br>
         <span class="prop">-setprop cpa.predicate.invariants.appendToAbstractionFormula=true</span><br>
         <span class="prop">-timelimit 600s</span><br>
         <span class="prop">-stats</span><br>
         <span class="prop">-spec test/programs/benchmarks/heap-manipulation/ALL.prp</span><br>
         <span class="prop">test/programs/benchmarks/heap-manipulation/sll_to_dll_rev_false-unreach-call.i</span>
         </code>
    </div>

    <h2>Benchmarking Configurations</h2>
    <p>
        In order to allow reproducibility of the evaluation, this section briefly describes how the necessary CPAchecker revisions
        can be obtained and which configurations were used.
    </p>

    <div class="howto">
        <p>
            CPAchecker needs to be available in revision 23084 (trunk), for the path invariants benchmarks either in revision 23143 (trunk) or better 23146 (branches/pathInvariants-fix).
            Furthermore some benchmarks with Z3 as solver were done on revision 23206 after the main evaluation was finished.
           Additionally we need the benchmarks from the SV-Comp. They are available in the <code>c</code> folder
           of the <a href="https://github.com/sosy-lab/sv-benchmarks">SV-Comp GitHub repository</a>.
                </p>
        <ol>
            <li>Change into the CPAchecker directory</li>
            <li>Download all dependencies and build CPAchecker by executing <code>ant</code></li>
            <li>
                Run the shell script <code>scripts/benchmark.py</code>, for example, by using the command below:</br>
                <code>
                    scripts/benchmark.py path/to/predicate_bitprecise_parallel.xml
                </code>
            </li>
            <li> The command above expects the correct path to your benchmark configuration file. Please note that you might have to adjust the paths in the benchmark set files referenced
                in the used benchmark configuration. For comparable results the used CPU should be the same as the one used in our experiments.</li>
            <li>The results (log files and data) will be placed in the directory <code>test/results/</code>.
            </li>
        </ol>
        </div>
        <div class="howto">
        <p>All benchmark configurations are listed here:</p>
        <ul>
        <li><a href="./supplementary/setup/base.xml">Baseline 300s</a></li>
        <li><a href="./supplementary/setup/base_longtimeout.xml">Baseline 600s</a></li>
        <li><a href="./supplementary/setup/base_parallel.xml">Baseline, Portofolio of Predicate Analysis and Invariant Generation</a></li>
        <li>Inductive Weakening of Path Formulas<ul>
            <li><a href="./supplementary/setup/weakening.xml">MathSAT5 as SMT solver</a></li>
            <li><a href="./supplementary/setup/z3_weakening.xml">Z3 as SMT solver</a></li>
          </ul>
          <li>Inductive Weakening of Path Formulas<ul>
              <li><a href="./supplementary/setup/cnfKind.xml">MathSAT5 as SMT solver</a></li>
              <li><a href="./supplementary/setup/z3_cnfKind.xml">Z3 as SMT solver</a></li>
            </ul>
        <li><a href="./supplementary/setup/interpolKind.xml">Checking Interpolants on Invariance (Abstraction at Loop Heads)</a></li>
        <li><a href="./supplementary/setup/alwaysAtJoin.xml">Checking Interpolants on Invariance (Abstraction at Loop Heads and Join Points)</a></li>
        <li><a href="./supplementary/setup/pathInvariants.xml">Path Invariants</a></li>
        <li><a href="./supplementary/setup/parallel.xml">Parallel Combinations ofAnalyses</a></li>
        <li><a href="./supplementary/setup/restart.xml">Sequential Combinations of Analyses</a></li>
        </ul>
        </div>
        <div class="howto">
        <p>All benchmark sets are listed here:</p>
        <ul>
        <li><a href="./supplementary/setup/benchmark64_false.set">All Unsafe 64bit Programs</a></li>
        <li><a href="./supplementary/setup/benchmark64_true.set">All Safe 64bit Programs</a></li>
        <li><a href="./supplementary/setup/benchmarkLoops_false.set">All Unsafe Programs of the Loops Category</a></li>
        <li><a href="./supplementary/setup/benchmarkLoops_true.set">All Safe Programs of the Loops Category</a></li>
        <li><a href="./supplementary/setup/benchmarkOther_false.set">All Other Unsafe Programs</a></li>
        <li><a href="./supplementary/setup/benchmarkOther_true.set">All Other Safe Programs</a></li>
        </ul>
        
    </div>

</div>
</body>
</html>
